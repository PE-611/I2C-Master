///////////////////////////////////////////////////////////
// Name File : I2C Master.v 										//
// Autor : Dyomkin Pavel Mikhailovich 							//
// Company : GSC RF TRINITI										//
// Description : I2C master module							  	//
// Start design : 23.04.2021 										//
// Last revision : 26.04.2021 									//
///////////////////////////////////////////////////////////
module main (input clk, transmit_enable, reset,
				 //input reg [7:0],
				 output reg antibounce_flg,  SCL,
				 inout SDA
				);
		
reg [28:0] abnc_cnt;
		
		
		
reg [7:0] state;	
reg [7:0] next_state;
reg [7:0] state_cnt;


localparam IDLE 						= 8'd0;
localparam START_CONDITION 		= 8'd1;
localparam DOWN_SCL					= 8'd2;
localparam BIT_SET_SDA				= 8'd3;
localparam BIT_APP_SCL           = 8'd4;
/*
localparam TICK_FOR_"A"_BIT  		= 8'd5;
localparam CHECK_SDA             = 8'd6;
localparam END_CONDITION 			= 8'd7;	
localparam END_TRANSMIT 			= 8'd8;
*/
				 
reg [12:0] cnt;
reg enable_cnt;


reg [7:0] DATA [2:0];
reg [7:0] data;
initial data <= 8'd160;

reg [7:0] bit_cnt;
initial bit_cnt <= 8'd7;



assign SDA = (state == BIT_APP_SCL) ? in_sda : out_sda;




reg in_sda;
initial in_sda <= 1'b1;
reg out_sda;
initial out_sda <= 1'b1;
initial SCL <= 1'b1;

always @* 	
		
		case (state)
			
			IDLE:
						
				
				if (transmit_enable <= 1'b0 && antibounce_flg <= 1'b0) begin
					next_state <= START_CONDITION;
					enable_cnt <= 1'b1;/////////
				end
				
				else begin
					next_state <= IDLE;
				end
				
			START_CONDITION:
				
				if (cnt == 12'd500) begin
					next_state <= DOWN_SCL;
					enable_cnt <= 1'b1;
				end
				
				else begin
					next_state <= START_CONDITION;
				end
				
			DOWN_SCL:
					
				if (cnt == 12'd750) begin
					next_state <= BIT_SET_SDA; 
				end
				
				else if (cnt == 12'd1500) begin
					
					enable_cnt <= 1'b0;
					
					
					if (bit_cnt == 8'd7) begin
						next_state <= IDLE;
					end
					
					else begin
						next_state <= BIT_SET_SDA;

					end
					
				end
				
				else begin
					next_state <= DOWN_SCL;
				end
			
			BIT_SET_SDA:	
				
				if (cnt == 12'd1000) begin
					next_state <= BIT_APP_SCL;
				end
				
				else begin
					next_state <= BIT_SET_SDA;
				end
				
			BIT_APP_SCL:
				
				if (cnt == 12'd1200) begin;
					next_state <= DOWN_SCL;
				end
				
				else begin
					next_state <= BIT_APP_SCL;
				end
				
				
				
	/*				
			TICK_FOR_"A"_BIT:
				
				if (abnc_cnt <= 28'd4000) begin
					next_state <= CHECK_SDA;
				end
				
				else begin
					next_state <= TICK_FOR_A_BIT;
				end
				
			CHECK_SDA:
				
				if (abnc_cnt <= 28'd5000) begin
					next_state <= END_CONDITION;
				end
				
				else begin
					next_state <= CHECK_SDA;
				end
				
			END_CONDITION: 
				
				if (abnc_cnt <= 28'd6000) begin
					next_state <= END_TRANSMIT;
				end
				
				else begin
					next_state <= END_CONDITION;
				end
				
			END_TRANSMIT:
			
				if (abnc_cnt <= 28'd7000) begin
					next_state <= IDLE;
				end
				
				else begin
					next_state <= END_TRANSMIT;
				end
			
			default:
				next_state <= IDLE;
				
			DELAY:
				if (x == xx || y == yy) begin
					
				end
				
				else begin
					next_state <= DELAY;
				end
		*/	
		
		endcase


always @(posedge clk) begin
	
	
	if (transmit_enable == 1'b0) begin
		antibounce_flg <= 1'b1;
	end
	
	if (antibounce_flg == 1'b1) begin
		abnc_cnt <= abnc_cnt + 1'b1;
	end
	
	if (abnc_cnt == 28'd50000000) begin
		antibounce_flg <= 1'b0;
		abnc_cnt <= 1'b0;
	end
	
		
		
		
		
	if (enable_cnt == 1'b1) begin
		cnt <= cnt + 1'b1;
	end
	
	if (enable_cnt == 1'b0) begin
		cnt <= 1'b0;
	end


	
	
	
	
	if (state == IDLE) begin
		out_sda <= 1'b1;
		SCL <= 1'b1;
//		enable_cnt <= 1'b0;
		cnt <= 1'b0;
	end
	
	if (state == START_CONDITION) begin
		out_sda <= 1'b0;
		SCL <= 1'b1;
//		enable_cnt <= 1'b1;
	end
	
	if (state == DOWN_SCL) begin
		SCL <= 1'b0;
	end
	
	if (state == BIT_SET_SDA) begin
		out_sda <= data[bit_cnt];
	end
	
	if (state == BIT_APP_SCL) begin
		SCL <= 1'b1;
	
	end


				
		
		
end	


always @(posedge clk or negedge reset) begin //

	if(!reset) begin
		state <= IDLE;
	end
	
	else begin
		state <= next_state;
	end
end				

		
endmodule


//data_out <=  {data_out[7:0], Rx_in}; shift reg